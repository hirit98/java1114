 @추상클래스
 일반 클래스와 동일하다 -> 추상메서드를 정의해서 사용한다
 추상 메서드를 추상클래스에서 선언하면 무조건 자식메서드에서 오버라이딩 해야한다.
 추상 클래스 : 추상 메서드가 항상 존재한다 (X)
     abstract  멤버변수와 생성자를 사용할 수 있다(O)
               추상메서드선언부에 선언했다.
               추상 클래스를 상속받는 클래스는 무조건 오버라이딩 한다(O)

 @인터페이스
 추상 메서드랑 상수만 선언할수있다.
 인터페이스는 클래스가 아니고, 스스로 객체를 생성 할 수 없다.
 어떤 형태로도 객체를 만들수 없기 때문에 클래스라고 부를수 없다.
 인터페이스는 필드와 생성자를 가질수 없고 오직 추상메서드와 상수만 포함.
 interface 인터페이스이름() {
       public static final 타입 상수이름  = 값;
       public abstract 메서드이름(메개변수목록);
}
1) 추상 메서드 집합이라서 추상 클래스보다 추상화가 높다
2) 인터페이스 모든 멤버는 public 이다.
   public static final -> 명시 안해도 자동으로 인식한다.(자동적 컴파일)

 @인터페이스 구현/다형성 사용방법
1) 인터페이스 정의된 추상메서드를 완성하며 인터페이스 자체의 추상 메서드를 구현해줄 클래스를 작성해야한다.
부모 인터페이스 : 메서드를 모두 사용하지 않을 경우
자식 클래스 : abstract 꼭 정의한다.
2) 인터페이스 : 다중 상속이 가능하다.(선언부만 존재하기 때문에)
*클래스는 단일 상속 : 부모의 메서드를 상속받는데 메서드는 구현부가 존재한다. 메서드가 동일할 경우는 
구현부가 다르기 때문에 자식이 혼란스러워 함. 때문에 자식이 어떤걸 선택할 지 모른다.
3) 인터페이스 다형성 가능하다.
*자식 클래스 메서드를 만들고 리턴 타입으로 부모형(인터페이스) 반환 가능하다.
main static : Fightable f = new Fighter(); // 자식객체
Fighter 클래스 메서드를 이용해서 반환가능(Fightable method() {return f;})

Q. 추상 클래스, 인터페이스 의 공통점
- 미완성 설계도이며, 추상 메서드를 가지고 있다.
(모듈화: 독립적으로 구현/사용가능 객체변경이 필요할때 수정이 최소화, 
정보은닉: 실제로 구현한 클래스의 내용을 보지 않아도 개발코드 객체 사용, 
추상화: 더 생각해서 만들어야 하는 부분)
Q. 추상 클래스, 인터페이스의 차이점
- 인터페이스 IV(인터페이스멤버: 변수/메서드)를 가질수 없다.
(인터페이스는 추상화가 심화 된 상황이며 구현 될 수 없고 추상 메서드로 캡슐화 사용한다.)

 @다중 인터페이스 구현
[접근제한자] class 클래스이름 implements 인터페이스1, 인터페이스2 ... {
 	// 필드변수
 	// 생성자
 	// 인터페이스1 구현 메서드 (추상 오버라이딩 = 구현)
 	// 인터페이스2 구현 메서드 (추상 오버라이딩 = 구현)
}

// 스피커
// 마이크폰
// 블루투스 마이크

1) 인터페이스 각 기능들을 따로 선언하고 자식들에게 다중 상속한다.

 @인터페이스 상속
[접근제한자] interface 인터페이스이름 extends 인터페이스1, 인터페이스2 ...{
	// 추상 메서드
}
 @인터페이스 장점
