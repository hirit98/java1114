@ 컬렉션 프레임워크
프로그램 실행 시 메모리에 자료를 유지하고 관리하며 배열의 제약의 단점을 보완 할 수 있다.
자료구조(stack/ queue/ Tree) 미리 구현 할 수 있는 인터페이스 모임이다.

@List
배열과 비슷한 자료구조 중복이 허용되며, 저장 순서가 유지되는 구조이다.
인덱스를 사용해서 데이터를 저장하고 찾을 수는 있지만 배열과 다르게 크기의 제한이 없는 저장 구조이다.
-ArrayList
JDK 1.2부터 제공되었으며 내부적으로 배열을 이용 할 수 있고 호환성이 좋은 자료구조이다.
인덱스의 위치에 저장 공간을 자유롭게 이동하고 저장/삭제 할 수 있다.
List <데이터 타입> list = new ArrayList<데이터 타입>();

-LinkedList
데이터의 주소를 가지는 노드 객체가 연결되어 데이터를 저장하는 구조이다. LinkedList 는 node 라는 객체를 생성해서 인접 데이터를
링크하는 형태로 체인처럼 관리한다. 추가/ 삭제할 때 성능이 좋아진다.

@Set 컬렉션
순서를 유지하지 않는 데이터 집합이고 데이터 중복을 허용하지 않는다. 인덱스를 부여하지 않기 때문에 데이터 입력된 순서로
출력한다는 보장이 없다.
-HashSet
동일한 값 또는 객체를 허용하지 않고 HashCode 값을 비교하여서 두 객체가 같음을 비교 할 수 있다.
Set<E> = new HashSet<E>();
1. 데이터 저장
2. 데이터 삭제
-LinkedHashSet

@Map
List/ Set 컬렉션과 다르게 map 인터페이스가 별도로 존재하며 데이터를 List 계열의 컬렉션과 다르게 처리한다.
중복은 key-허용하지 않고. value-허용하는 방식이다.
-HashMap<K,V>
Hash 와 속성이 같지만 map, Entry 구조를 저장하고 해당 객체는 key 와 value 를 저장한다.
검색을 요구하는 데이터는 효과적이지만 데이터를 저장하고 삭제 할 때는 느린편이다.
*Hashing 을 통해 키 중복을 허용 할 수 있다.
Map<Key, Value> map = new HashMap<KEY, VALUE>();